From 71d3f299dee2cbe5616019003524c929f173a938 Mon Sep 17 00:00:00 2001
From: ghmartin77
Date: Sun, 24 Dec 2017 00:38:04 +0100
Subject: [PATCH] Add further WS2801 types: RBG and BGR

---
 Adafruit_WS2801.cpp | 370 +++++++++++++++++++++++++++++-----------------------
 Adafruit_WS2801.h   |   2 +
 2 files changed, 207 insertions(+), 165 deletions(-)

diff --git a/Adafruit_WS2801.cpp b/Adafruit_WS2801.cpp
index 927bdec..8cc70d6 100644
--- a/Adafruit_WS2801.cpp
+++ b/Adafruit_WS2801.cpp
@@ -9,11 +9,11 @@
 // Teensy/Gemma-specific stuff for hardware-assisted SPI @ 1 MHz
 
 #if(F_CPU > 8000000L)
-  #define SPI_DELAY asm volatile("rjmp .+0\nrjmp .+0"); // Burn 4 cycles
+#define SPI_DELAY asm volatile("rjmp .+0\nrjmp .+0"); // Burn 4 cycles
 #elif(F_CPU > 4000000L)
-  #define SPI_DELAY asm volatile("rjmp .+0");           // Burn 2 cycles
+#define SPI_DELAY asm volatile("rjmp .+0");           // Burn 2 cycles
 #else
-  #define SPI_DELAY                                     // Run max speed
+#define SPI_DELAY                                     // Run max speed
 #endif
 
 #define SPIBIT                                  \
@@ -23,15 +23,15 @@
   SPI_DELAY
 
 static void spi_out(uint8_t n) {
-  USIDR = n;
-  SPIBIT
-  SPIBIT
-  SPIBIT
-  SPIBIT
-  SPIBIT
-  SPIBIT
-  SPIBIT
-  SPIBIT
+	USIDR = n;
+	SPIBIT
+	SPIBIT
+	SPIBIT
+	SPIBIT
+	SPIBIT
+	SPIBIT
+	SPIBIT
+	SPIBIT
 }
 
 #else
@@ -47,16 +47,17 @@ static void spi_out(uint8_t n) {
 
 // Constructor for use with hardware SPI (specific clock/data pins):
 Adafruit_WS2801::Adafruit_WS2801(uint16_t n, uint8_t order) {
-  rgb_order = order;
-  alloc(n);
-  updatePins();
+	rgb_order = order;
+	alloc(n);
+	updatePins();
 }
 
 // Constructor for use with arbitrary clock/data pins:
-Adafruit_WS2801::Adafruit_WS2801(uint16_t n, uint8_t dpin, uint8_t cpin, uint8_t order) {
-  rgb_order = order;
-  alloc(n);
-  updatePins(dpin, cpin);
+Adafruit_WS2801::Adafruit_WS2801(uint16_t n, uint8_t dpin, uint8_t cpin,
+		uint8_t order) {
+	rgb_order = order;
+	alloc(n);
+	updatePins(dpin, cpin);
 }
 
 // Constructor for use with a matrix configuration, specify w, h for size
@@ -64,18 +65,19 @@ Adafruit_WS2801::Adafruit_WS2801(uint16_t n, uint8_t dpin, uint8_t cpin, uint8_t
 // and continues to w-1,0, w-1,1 and on to 0,1, 0,2 and on to w-1,2 and
 // so on. Snaking back and forth till the end.  Other function calls
 // provide access to pixels via an x,y coordinate system
-Adafruit_WS2801::Adafruit_WS2801(uint16_t w, uint16_t h, uint8_t dpin, uint8_t cpin, uint8_t order) {
-  rgb_order = order;
-  alloc(w * h);
-  width  = w;
-  height = h;
-  updatePins(dpin, cpin);
+Adafruit_WS2801::Adafruit_WS2801(uint16_t w, uint16_t h, uint8_t dpin,
+		uint8_t cpin, uint8_t order) {
+	rgb_order = order;
+	alloc(w * h);
+	width = w;
+	height = h;
+	updatePins(dpin, cpin);
 }
 
 // Allocate 3 bytes per pixel, init to RGB 'off' state:
 void Adafruit_WS2801::alloc(uint16_t n) {
-  begun   = false;
-  numLEDs = ((pixels = (uint8_t *)calloc(n, 3)) != NULL) ? n : 0;
+	begun = false;
+	numLEDs = ((pixels = (uint8_t *) malloc(n * 3)) != NULL) ? n : 0;
 }
 
 // via Michael Vogt/neophob: empty constructor is used when strand length
@@ -85,207 +87,245 @@ void Adafruit_WS2801::alloc(uint16_t n) {
 // and updatePins() to establish the strand length and output pins!
 // Also, updateOrder() to change RGB vs GRB order (RGB is default).
 Adafruit_WS2801::Adafruit_WS2801(void) {
-  begun     = false;
-  numLEDs   = 0;
-  pixels    = NULL;
-  rgb_order = WS2801_RGB;
-  updatePins(); // Must assume hardware SPI until pins are set
+	begun = false;
+	numLEDs = 0;
+	pixels = NULL;
+	rgb_order = WS2801_RGB;
+	updatePins(); // Must assume hardware SPI until pins are set
 }
 
 // Release memory (as needed):
 Adafruit_WS2801::~Adafruit_WS2801(void) {
-  if(pixels) free(pixels);
+	if (pixels)
+		free(pixels);
 }
 
 // Activate hard/soft SPI as appropriate:
 void Adafruit_WS2801::begin(void) {
-  if(hardwareSPI == true) {
-    startSPI();
-  } else {
-    pinMode(datapin, OUTPUT);
-    pinMode(clkpin , OUTPUT);
-  }
-  begun = true;
+	if (hardwareSPI == true) {
+		startSPI();
+	} else {
+		pinMode(datapin, OUTPUT);
+		pinMode(clkpin, OUTPUT);
+	}
+	begun = true;
 }
 
 // Change pin assignments post-constructor, switching to hardware SPI:
 void Adafruit_WS2801::updatePins(void) {
-  pinMode(datapin, INPUT); // Restore data and clock pins to inputs
-  pinMode(clkpin , INPUT);
-  datapin     = clkpin = 0;
-  hardwareSPI = true;
-  // If begin() was previously invoked, init the SPI hardware now:
-  if(begun == true) startSPI();
-  // Otherwise, SPI is NOT initted until begin() is explicitly called.
+	pinMode(datapin, INPUT); // Restore data and clock pins to inputs
+	pinMode(clkpin, INPUT);
+	datapin = clkpin = 0;
+	hardwareSPI = true;
+	// If begin() was previously invoked, init the SPI hardware now:
+	if (begun == true)
+		startSPI();
+	// Otherwise, SPI is NOT initted until begin() is explicitly called.
 }
 
 // Change pin assignments post-constructor, using arbitrary pins:
 void Adafruit_WS2801::updatePins(uint8_t dpin, uint8_t cpin) {
-  if(begun == true) { // If begin() was previously invoked...
-    // If previously using hardware SPI, turn that off:
-    if(hardwareSPI) {
+	if (begun == true) { // If begin() was previously invoked...
+		// If previously using hardware SPI, turn that off:
+		if (hardwareSPI) {
 #ifdef __AVR_ATtiny85__
-      DDRB &= ~(_BV(PORTB1) | _BV(PORTB2));
+			DDRB &= ~(_BV(PORTB1) | _BV(PORTB2));
 #else
-      SPI.end();
+			SPI.end();
 #endif
-    } else {
-      pinMode(datapin, INPUT); // Restore prior data and clock pins to inputs
-      pinMode(clkpin , INPUT);
-    }
-    pinMode(dpin, OUTPUT); // Enable output on 'soft' SPI pins:
-    pinMode(cpin, OUTPUT);
-  }
-
-  datapin     = dpin;
-  clkpin      = cpin;
+		} else {
+			pinMode(datapin, INPUT); // Restore prior data and clock pins to inputs
+			pinMode(clkpin, INPUT);
+		}
+		pinMode(dpin, OUTPUT); // Enable output on 'soft' SPI pins:
+		pinMode(cpin, OUTPUT);
+	}
+
+	datapin = dpin;
+	clkpin = cpin;
 #ifdef __AVR__
-  clkport     = portOutputRegister(digitalPinToPort(cpin));
-  clkpinmask  = digitalPinToBitMask(cpin);
-  dataport    = portOutputRegister(digitalPinToPort(dpin));
-  datapinmask = digitalPinToBitMask(dpin);
+	clkport = portOutputRegister(digitalPinToPort(cpin));
+	clkpinmask = digitalPinToBitMask(cpin);
+	dataport = portOutputRegister(digitalPinToPort(dpin));
+	datapinmask = digitalPinToBitMask(dpin);
 #endif
-  hardwareSPI = false;
+	hardwareSPI = false;
 }
 
 // Enable SPI hardware and set up protocol details:
 void Adafruit_WS2801::startSPI(void) {
 #ifdef __AVR_ATtiny85__
-  PORTB &= ~(_BV(PORTB1) | _BV(PORTB2)); // Outputs
-  DDRB  |=   _BV(PORTB1) | _BV(PORTB2);  // DO (NOT MOSI) + SCK
+	PORTB &= ~(_BV(PORTB1) | _BV(PORTB2)); // Outputs
+	DDRB |= _BV(PORTB1) | _BV(PORTB2);// DO (NOT MOSI) + SCK
 #else
-  SPI.begin();
-  SPI.setBitOrder(MSBFIRST);
-  SPI.setDataMode(SPI_MODE0);
- #if defined(__AVR__) || defined(CORE_TEENSY)
-  SPI.setClockDivider(SPI_CLOCK_DIV16); // 1MHz max, else flicker
- #else
-  SPI.setClockDivider((F_CPU + 500000L) / 1000000L);
- #endif
+	SPI.begin();
+	SPI.setBitOrder(MSBFIRST);
+	SPI.setDataMode(SPI_MODE0);
+#if defined(__AVR__) || defined(CORE_TEENSY)
+	SPI.setClockDivider(SPI_CLOCK_DIV16); // 1MHz max, else flicker
+#else
+	SPI.setClockDivider((F_CPU + 500000L) / 1000000L);
+#endif
 #endif
 }
 
 uint16_t Adafruit_WS2801::numPixels(void) {
-  return numLEDs;
+	return numLEDs;
 }
 
 // Change strand length (see notes with empty constructor, above):
 void Adafruit_WS2801::updateLength(uint16_t n) {
-  if(pixels != NULL) free(pixels); // Free existing data (if any)
-  // Allocate new data -- note: ALL PIXELS ARE CLEARED
-  numLEDs = ((pixels = (uint8_t *)calloc(n, 3)) != NULL) ? n : 0;
-  // 'begun' state does not change -- pins retain prior modes
+	if (pixels != NULL)
+		free(pixels); // Free existing data (if any)
+	// Allocate new data -- note: ALL PIXELS ARE CLEARED
+	numLEDs = ((pixels = (uint8_t *) malloc(n * 3)) != NULL) ? n : 0;
+	// 'begun' state does not change -- pins retain prior modes
 }
 
 // Change RGB data order (see notes with empty constructor, above):
 void Adafruit_WS2801::updateOrder(uint8_t order) {
-  rgb_order = order;
-  // Existing LED data, if any, is NOT reformatted to new data order.
-  // Calling function should clear or fill pixel data anew.
+	rgb_order = order;
+	// Existing LED data, if any, is NOT reformatted to new data order.
+	// Calling function should clear or fill pixel data anew.
 }
 
 void Adafruit_WS2801::show(void) {
-  uint16_t i, nl3 = numLEDs * 3; // 3 bytes per LED
-  uint8_t  bit;
-
-  // Write 24 bits per pixel:
-  if(hardwareSPI) {
-    for(i=0; i<nl3; i++) spi_out(pixels[i]);
-  } else {
-    for(i=0; i<nl3; i++ ) {
-      for(bit=0x80; bit; bit >>= 1) {
+	uint16_t i, nl3 = numLEDs * 3; // 3 bytes per LED
+	uint8_t bit;
+
+	// Write 24 bits per pixel:
+	if (hardwareSPI) {
+		for (i = 0; i < nl3; i++)
+			spi_out(pixels[i]);
+	} else {
+		for (i = 0; i < nl3; i++) {
+			for (bit = 0x80; bit; bit >>= 1) {
 #ifdef __AVR__
-        if(pixels[i] & bit) *dataport |=  datapinmask;
-        else                *dataport &= ~datapinmask;
-        *clkport |=  clkpinmask;
-        *clkport &= ~clkpinmask;
+				if(pixels[i] & bit) *dataport |= datapinmask;
+				else *dataport &= ~datapinmask;
+				*clkport |= clkpinmask;
+				*clkport &= ~clkpinmask;
 #else
-        if(pixels[i] & bit) digitalWrite(datapin, HIGH);
-        else                digitalWrite(datapin, LOW);
-        digitalWrite(clkpin, HIGH);
-        digitalWrite(clkpin, LOW);
+				if (pixels[i] & bit)
+					digitalWrite(datapin, HIGH);
+				else
+					digitalWrite(datapin, LOW);
+				digitalWrite(clkpin, HIGH);
+//		delayMicroseconds(2);
+				digitalWrite(clkpin, LOW);
+//		delayMicroseconds(2);
 #endif
-      }
-    }
-  }
+			}
+		}
+	}
 
-  delay(1); // Data is latched by holding clock pin low for 1 millisecond
+	delay(1); // Data is latched by holding clock pin low for 1 millisecond
 }
 
 // Set pixel color from separate 8-bit R, G, B components:
-void Adafruit_WS2801::setPixelColor(uint16_t n, uint8_t r, uint8_t g, uint8_t b) {
-  if(n < numLEDs) { // Arrays are 0-indexed, thus NOT '<='
-    uint8_t *p = &pixels[n * 3];
-    // See notes later regarding color order
-    if(rgb_order == WS2801_RGB) {
-      *p++ = r;
-      *p++ = g;
-    } else {
-      *p++ = g;
-      *p++ = r;
-    }
-    *p++ = b;
-  }
+void Adafruit_WS2801::setPixelColor(uint16_t n, uint8_t r, uint8_t g,
+		uint8_t b) {
+	if (n < numLEDs) { // Arrays are 0-indexed, thus NOT '<='
+		uint8_t *p = &pixels[n * 3];
+		// See notes later regarding color order
+		if (rgb_order == WS2801_RGB) {
+			*p++ = r;
+			*p++ = g;
+			*p++ = b;
+		} else if (rgb_order == WS2801_RBG) {
+			*p++ = r;
+			*p++ = b;
+			*p++ = g;
+		} else if (rgb_order == WS2801_GRB) {
+			*p++ = g;
+			*p++ = r;
+			*p++ = b;
+		} else if (rgb_order == WS2801_BGR) {
+			*p++ = b;
+			*p++ = g;
+			*p++ = r;
+		}
+	}
 }
 
 // Set pixel color from separate 8-bit R, G, B components using x,y coordinate system:
-void Adafruit_WS2801::setPixelColor(uint16_t x, uint16_t y, uint8_t r, uint8_t g, uint8_t b) {
-  boolean evenRow = ((y % 2) == 0);
-  // calculate x offset first
-  uint16_t offset = x % width;
-  if (!evenRow) {
-    offset = (width-1) - offset;
-  }
-  // add y offset
-  offset += y * width;
-  setPixelColor(offset, r, g, b);
+void Adafruit_WS2801::setPixelColor(uint16_t x, uint16_t y, uint8_t r,
+		uint8_t g, uint8_t b) {
+	boolean evenRow = ((y % 2) == 0);
+	// calculate x offset first
+	uint16_t offset = x % width;
+	if (!evenRow) {
+		offset = (width - 1) - offset;
+	}
+	// add y offset
+	offset += y * width;
+	setPixelColor(offset, r, g, b);
 }
 
 // Set pixel color from 'packed' 32-bit RGB value:
 void Adafruit_WS2801::setPixelColor(uint16_t n, uint32_t c) {
-  if(n < numLEDs) { // Arrays are 0-indexed, thus NOT '<='
-    uint8_t *p = &pixels[n * 3];
-    // To keep the show() loop as simple & fast as possible, the
-    // internal color representation is native to different pixel
-    // types.  For compatibility with existing code, 'packed' RGB
-    // values passed in or out are always 0xRRGGBB order.
-    if(rgb_order == WS2801_RGB) {
-      *p++ = c >> 16; // Red
-      *p++ = c >>  8; // Green
-    } else {
-      *p++ = c >>  8; // Green
-      *p++ = c >> 16; // Red
-    }
-    *p++ = c;         // Blue
-  }
+	if (n < numLEDs) { // Arrays are 0-indexed, thus NOT '<='
+		uint8_t *p = &pixels[n * 3];
+		// To keep the show() loop as simple & fast as possible, the
+		// internal color representation is native to different pixel
+		// types.  For compatibility with existing code, 'packed' RGB
+		// values passed in or out are always 0xRRGGBB order.
+		if (rgb_order == WS2801_RGB) {
+			*p++ = c >> 16; // Red
+			*p++ = c >> 8; // Green
+			*p++ = c;         // Blue
+		} else if (rgb_order == WS2801_RBG) {
+			*p++ = c >> 16; // Red
+			*p++ = c; // Blue
+			*p++ = c >> 8;         // Green
+		} else if (rgb_order == WS2801_GRB) {
+			*p++ = c >> 8; // Green
+			*p++ = c >> 16; // Red
+			*p++ = c;         // Blue
+		} else {
+			*p++ = c;
+			*p++ = c >> 8;
+			*p++ = c >> 16;
+		}
+	}
 }
 
 // Set pixel color from 'packed' 32-bit RGB value using x,y coordinate system:
 void Adafruit_WS2801::setPixelColor(uint16_t x, uint16_t y, uint32_t c) {
-  boolean evenRow = ((y % 2) == 0);
-  // calculate x offset first
-  uint16_t offset = x % width;
-  if (!evenRow) {
-    offset = (width-1) - offset;
-  }
-  // add y offset
-  offset += y * width;
-  setPixelColor(offset, c);
+	boolean evenRow = ((y % 2) == 0);
+	// calculate x offset first
+	uint16_t offset = x % width;
+	if (!evenRow) {
+		offset = (width - 1) - offset;
+	}
+	// add y offset
+	offset += y * width;
+	setPixelColor(offset, c);
 }
 
 // Query color from previously-set pixel (returns packed 32-bit RGB value)
 uint32_t Adafruit_WS2801::getPixelColor(uint16_t n) {
-  if(n < numLEDs) {
-    uint16_t ofs = n * 3;
-    // To keep the show() loop as simple & fast as possible, the
-    // internal color representation is native to different pixel
-    // types.  For compatibility with existing code, 'packed' RGB
-    // values passed in or out are always 0xRRGGBB order.
-    return (rgb_order == WS2801_RGB) ?
-      ((uint32_t)pixels[ofs] << 16) | ((uint16_t) pixels[ofs + 1] <<  8) | pixels[ofs + 2] :
-      (pixels[ofs] <<  8) | ((uint32_t)pixels[ofs + 1] << 16) | pixels[ofs + 2];
-  }
-
-  return 0; // Pixel # is out of bounds
+	if (n < numLEDs) {
+		uint16_t ofs = n * 3;
+		// To keep the show() loop as simple & fast as possible, the
+		// internal color representation is native to different pixel
+		// types.  For compatibility with existing code, 'packed' RGB
+		// values passed in or out are always 0xRRGGBB order.
+		if (rgb_order == WS2801_RGB) {
+			return ((uint32_t) pixels[ofs] << 16)
+					| ((uint16_t) pixels[ofs + 1] << 8) | pixels[ofs + 2];
+		} else if (rgb_order == WS2801_RBG) {
+			return ((uint32_t) pixels[ofs] << 16)
+					| ((uint16_t) pixels[ofs + 2] << 8) | pixels[ofs + 1];
+		} else if (rgb_order == WS2801_GRB) {
+			return (pixels[ofs] << 8) | ((uint32_t) pixels[ofs + 1] << 16)
+					| pixels[ofs + 2];
+		} else {
+			return (pixels[ofs]) | ((uint32_t) pixels[ofs + 1] << 8)
+					| (pixels[ofs + 2] << 16);
+		}
+	}
+
+	return 0; // Pixel # is out of bounds
 }
 
diff --git a/Adafruit_WS2801.h b/Adafruit_WS2801.h
index cc0ca31..b064987 100644
--- a/Adafruit_WS2801.h
+++ b/Adafruit_WS2801.h
@@ -15,6 +15,8 @@
 // library will handle any required translation internally.
 #define WS2801_RGB 0
 #define WS2801_GRB 1
+#define WS2801_RBG 2
+#define WS2801_BGR 3
 
 class Adafruit_WS2801 {
 
-- 
2.10.1.windows.1

